/*  XPECT_SETUP
org.uqbar.project.wollok.tests.typesystem.xpect.TypeSystemXpectTestCase
END_SETUP  */

/** 
 * Tests generales a todas las collecciones
 *
 * Si bien los tests en esta clase son comunes a todas las colecciones, Wollok no podría tiparlo genericamente.
 * Para testear tanto lists como sets, esta clase está duplicada, salvo por la declaración de `sample`. 
 */	
class TestCollection {
	const sample = [1, 2, 3]

	method generalCollection() {
		// XPECT type  at asList --> List<Number>
		const asList = sample.asList()
		
		// XPECT type  at asSet --> Set<Number>
		const asSet = sample.asSet()
		
		// XPECT type  at isEmpty --> Boolean
		const isEmpty = sample.isEmpty()
		
		// XPECT type  at contains --> {(Number) => Boolean}
		const contains = { e => sample.contains(e) }
	
		// XPECT type  at occurrencesOf --> {(Number) => Number}
		const occurrencesOf = { e => sample.occurrencesOf(e) }

		// XPECT type  at size --> {() => Number}
		const size = { sample.size()) }

		// XPECT type  at anyOne --> {() => Number}
		const anyOne = { sample.anyOne() }

		// XPECT type  at add --> {(Number) => Void}
		const add = { e => sample.add(e) }

		// XPECT type  at remove --> {(Number) => Void}
		const remove = { e => sample.remove(e) }

		// XPECT type  at addAll --> {(Collection<Number>) => Void}
		const addAll = { l => sample.addAll(l) }

		// XPECT type  at removeAll --> {(Collection<Number>) => Void}
		const removeAll = { l => sample.removeAll(l) }
	}

	method basicClosures() {
		// XPECT type at forEach --> {({(Number) => Void}) => Void}
		const forEach = { action => sample.forEach(action) } 

		// XPECT type at filter --> {({(Number) => Boolean}) => List<Number>}
		const filter = { cond => sample.filter(cond) } 

		// XPECT type at find --> {({(Number) => Boolean}) => Number}
		const find = { predicate => sample.find(predicate) }

		// XPECT type at findOrDefault --> {({(Number) => Boolean}, Number) => Number}
		const findOrDefault = { predicate, defaultValue => sample.findOrDefault(predicate, defaultValue) }

		// XPECT type at findOrElse --> {({(Number) => Boolean}, {() => Number}) => Number}
		const findOrElse = { predicate, actionIfAbsent => sample.findOrElse(predicate, actionIfAbsent) }

		// XPECT type at removeAllSuchThat --> {({(Number) => Boolean}) => Void}
		const removeAllSuchThat = { closure => sample.removeAllSuchThat(closure) }

		// XPECT type at all --> {({(Number) => Boolean}) => Boolean}
		const all = { predicate => sample.all(predicate) }

		// XPECT type at any --> {({(Number) => Boolean}) => Boolean}
		const any = { predicate => sample.any(predicate) }

		// XPECT type at count --> {({(Number) => Boolean}) => Number}
		const count = { predicate => sample.count(predicate)}
	}
	
	// Requieren comparable	
	// method max(closure)
	//	method max()		
	//	method min(closure)
	//	method min() = self.min({it => it})
	// method sortedBy(closure)

	//	Requieren sumables
	//	method sum(closure) = self.fold(0, { acc, e => acc + closure.apply(e) })
	//	method sum() = self.sum( {it => it} )

	// Requiere method-scoped type parameters	
	method methodScopedTypeParameters() {
		// XPECT type at mapped --> List<Boolean>
		const mapped = sample.map { number => number.even() } 

		// XPECT type at flatMapped --> List<Boolean>
		const flatMapped = sample.flatMap { number => [number.even()] } 

		// XPECT type at fold --> Number
		const fold = sample.fold(0, { accum, elem => accum + elem }) 

		// XPECT! type at allEven --> List<Boolean>
		// const allEven = sample.fold(true, { accum, elem => accum && elem.even() }) 
	}
}

/**
 * Tests de métodos específicos de listas, 
 * o bien aquellos que devuelven un tipo distinto dependiendo del receptor (e.g. filter)
 */
class TestList {
	const sample = [1, 2, 3]

	method listSpecific() {
		// XPECT type  at first --> Number
		const first = sample.first() 	
	}

	method selfTyped() {
		// XPECT type  at filter --> {({(Number) => Boolean}) => List<Number>}
		const filter = { cond => sample.filter(cond) } 

	//	method +(elements) {
	//	method flatten() = self.flatMap { e => e }
	//	method copy() {
	//	method newInstance()			
	}
}